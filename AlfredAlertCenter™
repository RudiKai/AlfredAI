#property indicator_chart_window
#property strict
#property indicator_buffers 1
#property indicator_plots   1
#property indicator_type1   DRAW_NONE
#property indicator_label1  "AlfredAlertCenter"

double dummyBuffer[];

input bool EnableAlertCenter         = true;
input bool Alert_StrongBiasAligned  = true;
input bool Alert_Divergence         = true;
input bool Alert_ZoneEntry          = true;
input bool Alert_BiasFlip           = true;
input int  AlertConfidenceThreshold = 85;

string lastBias = "Neutral";

int OnInit()
{
   SetIndexBuffer(0, dummyBuffer, INDICATOR_DATA);
   ArrayInitialize(dummyBuffer, EMPTY_VALUE);
   return INIT_SUCCEEDED;
}

int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long &tick_volume[],
                const long &volume[],
                const int &spread[])
{
   if(!EnableAlertCenter) return rates_total;

   string magnetDir = GetMagnetDirection();
   string arrow, biasText;
   bool conflict = false;
   int confidence = GetCompassBias(magnetDir, arrow, biasText, conflict);

   //== Alert: Strong Bias Aligned ==
   if(Alert_StrongBiasAligned && confidence >= AlertConfidenceThreshold && !conflict)
      TriggerAlert("Strong Bias Aligned: " + biasText + " (" + IntegerToString(confidence) + "%)");

   //== Alert: Divergence Detected ==
   if(Alert_Divergence && conflict)
      TriggerAlert("Divergence Detected: Compass vs MagnetHUD");

   //== Alert: Zone Entry Confirmed ==
   if(Alert_ZoneEntry && IsInsideZone() && confidence >= AlertConfidenceThreshold)
      TriggerAlert("Zone Entry Confirmed: Price inside zone with active bias");

   //== Alert: Bias Flip Detected ==
   if(Alert_BiasFlip && biasText != lastBias && lastBias != "Neutral")
      TriggerAlert("Bias Flip Detected: " + lastBias + " â†’ " + biasText);

   lastBias = biasText;

   return rates_total;
}

//== Alert Dispatcher ==
void TriggerAlert(string msg)
{
   Print("ðŸ”” AlfredAlertCenter: ", msg);

   string obj = "AlertLabel_" + IntegerToString(TimeLocal());
   double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   datetime t = iTime(_Symbol, _Period, 0);

   ObjectCreate(0, obj, OBJ_TEXT, 0, t, price);
   ObjectSetInteger(0, obj, OBJPROP_FONTSIZE, 10);
   ObjectSetInteger(0, obj, OBJPROP_COLOR, clrOrangeRed);
   ObjectSetString(0, obj, OBJPROP_TEXT, msg);
   ObjectMove(0, obj, 0, t, price + 30 * _Point);

   // Optional: Push notification
   // SendNotification("AlfredOS Alert: " + msg);
}

//== Compass Scanner ==
int GetCompassBias(string magnetDir, string &arrow, string &biasText, bool &conflict)
{
   ENUM_TIMEFRAMES tfList[] = { PERIOD_M15, PERIOD_H1, PERIOD_H4 };
   int buy = 0, sell = 0;

   for(int i=0; i<ArraySize(tfList); i++)
   {
      ENUM_TIMEFRAMES tf = tfList[i];
      double slope = iMA(_Symbol, tf, 8, 3, MODE_SMA, PRICE_CLOSE) -
                     iMA(_Symbol, tf, 8, 0, MODE_SMA, PRICE_CLOSE);

      int upC=0, downC=0;
      for(int j=1; j<=5; j++)
      {
         double cNow = iClose(_Symbol, tf, j);
         double cPrev = iClose(_Symbol, tf, j+1);
         if(cNow > cPrev) upC++;
         if(cNow < cPrev) downC++;
      }

      if(slope > 0.0003 || upC >= 4) buy++;
      if(slope < -0.0003 || downC >= 4) sell++;
   }

   int confidence = 50;
   arrow = "â†’"; biasText = "Neutral";

   if(buy > sell)
   {
      arrow = "â†‘"; biasText = "Buy";
      confidence = 70 + buy * 5;
      conflict = (magnetDir == "ðŸ”´ Supply");
   }
   else if(sell > buy)
   {
      arrow = "â†“"; biasText = "Sell";
      confidence = 70 + sell * 5;
      conflict = (magnetDir == "ðŸŸ¢ Demand");
   }

   confidence = MathMin(confidence,100);
   return confidence;
}

//== MagnetHUD Direction ==
string GetMagnetDirection()
{
   string d,s,e;
   GetTFMagnet(PERIOD_H1,d,s,e);
   return d;
}

//== Zone Entry Check ==
bool IsInsideZone()
{
   string zones[] = {"DZone_LTF","DZone_H1","DZone_H4","DZone_D1",
                     "SZone_LTF","SZone_H1","SZone_H4","SZone_D1"};

   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   for(int i=0; i<ArraySize(zones); i++)
   {
      string z = zones[i];
      if(ObjectFind(0,z)>=0)
      {
         double p1 = ObjectGetDouble(0,z,OBJPROP_PRICE,0);
         double p2 = ObjectGetDouble(0,z,OBJPROP_PRICE,1);
         if(bid >= MathMin(p1,p2) && bid <= MathMax(p1,p2))
            return true;
      }
   }
   return false;
}

//== MagnetHUD Zone Reader ==
double GetTFMagnet(ENUM_TIMEFRAMES tf, string &direction, string &strength, string &eta)
{
   string demandZones[] = {"DZone_LTF","DZone_H1","DZone_H4","DZone_D1"};
   string supplyZones[] = {"SZone_LTF","SZone_H1","SZone_H4","SZone_D1"};
   double scoreD=-999, scoreS=-999, bestDemand=EMPTY_VALUE, bestSupply=EMPTY_VALUE;

   for(int i=0; i<ArraySize(demandZones); i++)
   {
      string z = demandZones[i];
      if(ObjectFind(0,z)>=0)
      {
         double p1=ObjectGetDouble(0,z,OBJPROP_PRICE,0);
         double p2=ObjectGetDouble(0,z,OBJPROP_PRICE,1);
         double mid=(p1+p2)/2;
         double dist=MathAbs(SymbolInfoDouble(_Symbol,SYMBOL_BID)-mid);
         double width=MathAbs(p1-p2);
         double score=1000 - dist/_Point - width/_Point;
         if(score > scoreD){ scoreD=score; bestDemand=mid; }
      }
   }

   for(int i=0; i<ArraySize(supplyZones); i++)
   {
      string z = supplyZones[i];
      if(ObjectFind(0,z)>=0)
      {
         double p1=ObjectGetDouble(0,z,OBJPROP_PRICE,0);
         double p2=ObjectGetDouble(0,z,OBJPROP_PRICE,1);
         double mid=(p1+p2)/2;
         double dist=MathAbs(SymbolInfoDouble(_Symbol,SYMBOL_BID)-mid);
         double width=MathAbs(p1-p2);
         double score=1000 - dist/_Point - width/_Point;
         if(score > scoreS){ scoreS=score; bestSupply=mid; }
      }
   }

   bool useDemand = (scoreD >= scoreS);
   direction = useDemand ? "ðŸŸ¢ Demand" : "ðŸ”´ Supply";
   strength = ""; eta = "~";
   return useDemand ? bestDemand : bestSupply;
}
