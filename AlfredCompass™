#property indicator_chart_window
#property strict
#property indicator_buffers 1
#property indicator_plots   1
#property indicator_type1   DRAW_NONE
#property indicator_label1  "AlfredCompass"

double dummyBuffer[];
input bool EnableCompassPhase3   = true;
input int  CompassOffsetPoints   = 20;

//== Core Timeframes for Validation ==
ENUM_TIMEFRAMES tfList[] = { PERIOD_M15, PERIOD_H1, PERIOD_H4 };

int OnInit()
{
   SetIndexBuffer(0, dummyBuffer, INDICATOR_DATA);
   ArrayInitialize(dummyBuffer, EMPTY_VALUE);
   return INIT_SUCCEEDED;
}

int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long &tick_volume[],
                const long &volume[],
                const int &spread[])
{
   if(!EnableCompassPhase3) return rates_total;

   string magnetDirection = GetMagnetDirection();
   string biasArrow, biasText, output;
   bool conflict = false;
   int confidence = GetCompassBias(magnetDirection, biasArrow, biasText, conflict);

   output = "üìç Compass Bias: " + biasArrow + " " + biasText +
            " [" + IntegerToString(confidence) + "% Confidence]";

   if(conflict) output += "\n‚ö†Ô∏è Divergence from MagnetHUD zone";

   // Display label near bid
   datetime t = iTime(_Symbol, _Period, 0);
   double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   string labelObj = "AlfredCompassPhase3";

   if(ObjectFind(0, labelObj) < 0)
      ObjectCreate(0, labelObj, OBJ_TEXT, 0, t, price);

   ObjectSetInteger(0, labelObj, OBJPROP_FONTSIZE, 10);
   ObjectSetInteger(0, labelObj, OBJPROP_COLOR, clrDodgerBlue);
   ObjectSetString(0, labelObj, OBJPROP_TEXT, output);
   ObjectMove(0, labelObj, 0, t, price + CompassOffsetPoints * _Point);

   return rates_total;
}

//== Get MagnetHUD Direction for Alignment Check ==
string GetMagnetDirection()
{
   string d, s, e;
   GetTFMagnet(PERIOD_H1, d, s, e);
   return d;
}

//== Aggregate Compass Bias Across Timeframes ==
int GetCompassBias(string magnetDirection, string &arrow, string &biasText, bool &conflict)
{
   int buyCount = 0, sellCount = 0;
   double slopeTotal = 0;

   for(int i = 0; i < ArraySize(tfList); i++)
   {
      ENUM_TIMEFRAMES tf = tfList[i];

      // MA slope
double maPrev = iMA(_Symbol, tf, 8, 3, MODE_SMA, PRICE_CLOSE); // ‚úÖ shifted back 3 bars
double maCurr = iMA(_Symbol, tf, 8, 0, MODE_SMA, PRICE_CLOSE); // ‚úÖ current bar
      double slope = maCurr - maPrev;
      slopeTotal += slope;

      // Candle flow
      int upC = 0, downC = 0;
      for(int j = 1; j <= 5; j++)
      {
         double cNow = iClose(_Symbol, tf, j);
         double cPrev = iClose(_Symbol, tf, j+1);
         if(cNow > cPrev) upC++;
         if(cNow < cPrev) downC++;
      }

      if(slope > 0.0003 || upC >= 4) buyCount++;
      if(slope < -0.0003 || downC >= 4) sellCount++;
   }

   arrow = "‚Üí"; biasText = "Neutral";
   int confidence = 50;

   if(buyCount > sellCount) {
      arrow = "‚Üë"; biasText = "Multi-TF Buy";
      confidence = 70 + buyCount * 5;
      conflict = (magnetDirection == "üî¥ Supply");
   } else if(sellCount > buyCount) {
      arrow = "‚Üì"; biasText = "Multi-TF Sell";
      confidence = 70 + sellCount * 5;
      conflict = (magnetDirection == "üü¢ Demand");
   }

   confidence = MathMin(confidence, 100);
   return confidence;
}

//== MagnetHUD Zone Reader ==
double GetTFMagnet(ENUM_TIMEFRAMES tf, string &direction, string &strength, string &eta)
{
   string demandZones[] = {"DZone_LTF","DZone_H1","DZone_H4","DZone_D1"};
   string supplyZones[] = {"SZone_LTF","SZone_H1","SZone_H4","SZone_D1"};

   double bestDemand = EMPTY_VALUE, scoreD = -999;
   double bestSupply = EMPTY_VALUE, scoreS = -999;

   for(int i=0; i<ArraySize(demandZones); i++)
   {
      string z = demandZones[i];
      if(ObjectFind(0,z)>=0)
      {
         double p1 = ObjectGetDouble(0,z,OBJPROP_PRICE,0);
         double p2 = ObjectGetDouble(0,z,OBJPROP_PRICE,1);
         double mid = (p1 + p2)/2;
         double dist = MathAbs(SymbolInfoDouble(_Symbol,SYMBOL_BID) - mid);
         double width = MathAbs(p1 - p2);
         double score = 1000 - dist/_Point - width/_Point;
         if(score > scoreD) { scoreD = score; bestDemand = mid; }
      }
   }

   for(int i=0; i<ArraySize(supplyZones); i++)
   {
      string z = supplyZones[i];
      if(ObjectFind(0,z)>=0)
      {
         double p1 = ObjectGetDouble(0,z,OBJPROP_PRICE,0);
         double p2 = ObjectGetDouble(0,z,OBJPROP_PRICE,1);
         double mid = (p1 + p2)/2;
         double dist = MathAbs(SymbolInfoDouble(_Symbol,SYMBOL_BID) - mid);
         double width = MathAbs(p1 - p2);
         double score = 1000 - dist/_Point - width/_Point;
         if(score > scoreS) { scoreS = score; bestSupply = mid; }
      }
   }

   bool useDemand = (scoreD >= scoreS);
   double finalScore = useDemand ? scoreD : scoreS;
   direction = useDemand ? "üü¢ Demand" : "üî¥ Supply";
   strength = ""; eta = "~";
   return useDemand ? bestDemand : bestSupply;
}
