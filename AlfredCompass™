#property indicator_chart_window
#property strict
#property indicator_buffers 1
#property indicator_plots   1
#property indicator_type1   DRAW_NONE
#property indicator_label1  "AlfredCompass"

double dummyBuffer[];
input bool EnableCompassPhase3_5 = true;
input int  CompassYOffset        = 20;
input int  CompassXOffset        = 10;

//== Reference TFs ==
ENUM_TIMEFRAMES tfList[] = { PERIOD_M15, PERIOD_H1, PERIOD_H4 };

int OnInit()
{
   SetIndexBuffer(0, dummyBuffer, INDICATOR_DATA);
   ArrayInitialize(dummyBuffer, EMPTY_VALUE);
   return INIT_SUCCEEDED;
}

int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long &tick_volume[],
                const long &volume[],
                const int &spread[])
{
   if(!EnableCompassPhase3_5) return rates_total;

   string magnetDir = GetMagnetDirection();
   string arrow, biasText;
   bool conflict = false;
   int confidence = GetCompassBias(magnetDir, arrow, biasText, conflict);

   color fontColor = StrengthColor(WeightToLabel(confidence/5));
   if(conflict) fontColor = clrRed;

   //== Draw Objects ==
   datetime t = iTime(_Symbol,_Period,0);
   double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);

   // Arrow
   string arrowObj = "CompassArrowObj";
   if(ObjectFind(0, arrowObj) < 0)
      ObjectCreate(0, arrowObj, OBJ_TEXT, 0, t, price);
   ObjectSetInteger(0, arrowObj, OBJPROP_FONTSIZE, 18);
   ObjectSetInteger(0, arrowObj, OBJPROP_COLOR, fontColor);
   ObjectSetString(0, arrowObj, OBJPROP_TEXT, arrow);
   ObjectMove(0, arrowObj, 0, t, price + CompassYOffset * _Point);

   // Label Text
   string labelObj = "CompassLabelObj";
   string labelText = biasText + " (" + IntegerToString(confidence) + "%)";
   if(ObjectFind(0, labelObj) < 0)
      ObjectCreate(0, labelObj, OBJ_TEXT, 0, t, price);
   ObjectSetInteger(0, labelObj, OBJPROP_FONTSIZE, 11);
   ObjectSetInteger(0, labelObj, OBJPROP_COLOR, fontColor);
   ObjectSetString(0, labelObj, OBJPROP_TEXT, labelText);
   ObjectMove(0, labelObj, 0, t, price + (CompassYOffset + 20) * _Point);

   // Divergence Warning
   string warnObj = "CompassConflictObj";
   if(conflict)
   {
      if(ObjectFind(0, warnObj) < 0)
         ObjectCreate(0, warnObj, OBJ_TEXT, 0, t, price);
      ObjectSetInteger(0, warnObj, OBJPROP_FONTSIZE, 10);
      ObjectSetInteger(0, warnObj, OBJPROP_COLOR, clrRed);
      ObjectSetString(0, warnObj, OBJPROP_TEXT, "⚠️ Conflict with MagnetHUD");
      ObjectMove(0, warnObj, 0, t, price + (CompassYOffset + 38) * _Point);
   }
   else if(ObjectFind(0, warnObj) >= 0)
      ObjectDelete(0, warnObj); // Remove warning if resolved

   return rates_total;
}

//== Compass Scanner ==
int GetCompassBias(string magnetDir, string &arrow, string &biasText, bool &conflict)
{
   int buy = 0, sell = 0;
   for(int i=0; i<ArraySize(tfList); i++)
   {
      ENUM_TIMEFRAMES tf = tfList[i];
      double slope = iMA(_Symbol, tf, 8, 3, MODE_SMA, PRICE_CLOSE) -
                     iMA(_Symbol, tf, 8, 0, MODE_SMA, PRICE_CLOSE);

      int upC=0, downC=0;
      for(int j=1; j<=5; j++)
      {
         double cNow = iClose(_Symbol, tf, j);
         double cPrev = iClose(_Symbol, tf, j+1);
         if(cNow > cPrev) upC++;
         if(cNow < cPrev) downC++;
      }

      if(slope > 0.0003 || upC >= 4) buy++;
      if(slope < -0.0003 || downC >= 4) sell++;
   }

   int confidence = 50;
   arrow = "→"; biasText = "Neutral";

   if(buy > sell)
   {
      arrow = "↑"; biasText = "Multi-TF Buy";
      confidence = 70 + buy * 5;
      conflict = (magnetDir == "🔴 Supply");
   }
   else if(sell > buy)
   {
      arrow = "↓"; biasText = "Multi-TF Sell";
      confidence = 70 + sell * 5;
      conflict = (magnetDir == "🟢 Demand");
   }

   confidence = MathMin(confidence,100);
   return confidence;
}

//== MagnetHUD Direction ==
string GetMagnetDirection()
{
   string d,s,e;
   GetTFMagnet(PERIOD_H1,d,s,e);
   return d;
}

//== MagnetHUD Zone Reader ==
double GetTFMagnet(ENUM_TIMEFRAMES tf, string &direction, string &strength, string &eta)
{
   string demandZones[] = {"DZone_LTF","DZone_H1","DZone_H4","DZone_D1"};
   string supplyZones[] = {"SZone_LTF","SZone_H1","SZone_H4","SZone_D1"};
   double scoreD=-999, scoreS=-999, bestDemand=EMPTY_VALUE, bestSupply=EMPTY_VALUE;

   for(int i=0; i<ArraySize(demandZones); i++)
   {
      string z = demandZones[i];
      if(ObjectFind(0,z)>=0)
      {
         double p1=ObjectGetDouble(0,z,OBJPROP_PRICE,0);
         double p2=ObjectGetDouble(0,z,OBJPROP_PRICE,1);
         double mid=(p1+p2)/2;
         double dist=MathAbs(SymbolInfoDouble(_Symbol,SYMBOL_BID)-mid);
         double width=MathAbs(p1-p2);
         double score=1000 - dist/_Point - width/_Point;
         if(score > scoreD){ scoreD=score; bestDemand=mid; }
      }
   }

   for(int i=0; i<ArraySize(supplyZones); i++)
   {
      string z = supplyZones[i];
      if(ObjectFind(0,z)>=0)
      {
         double p1=ObjectGetDouble(0,z,OBJPROP_PRICE,0);
         double p2=ObjectGetDouble(0,z,OBJPROP_PRICE,1);
         double mid=(p1+p2)/2;
         double dist=MathAbs(SymbolInfoDouble(_Symbol,SYMBOL_BID)-mid);
         double width=MathAbs(p1-p2);
         double score=1000 - dist/_Point - width/_Point;
         if(score > scoreS){ scoreS=score; bestSupply=mid; }
      }
   }

   bool useDemand = (scoreD >= scoreS);
   direction = useDemand ? "🟢 Demand" : "🔴 Supply";
   strength = ""; eta = "~";
   return useDemand ? bestDemand : bestSupply;
}

//== Label Strength Mapping ==
string WeightToLabel(int weight)
{
   if(weight <= 5) return "Very Weak";
   if(weight <= 10) return "Weak";
   if(weight <= 15) return "Neutral";
   if(weight <= 20) return "Strong";
   return "Very Strong";
}

color StrengthColor(string label)
{
   if(label=="Very Weak")   return clrGray;
   if(label=="Weak")        return clrSilver;
   if(label=="Neutral")     return clrKhaki;
   if(label=="Strong")      return clrAquamarine;
   if(label=="Very Strong") return clrLime;
   return clrWhite;
}
