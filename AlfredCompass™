#property indicator_chart_window
#property strict
#property indicator_buffers 1
#property indicator_plots   1
#property indicator_type1   DRAW_NONE
#property indicator_label1  "FloatingCompass"

double dummyBuffer[];

ENUM_TIMEFRAMES TFList[] = { PERIOD_H4, PERIOD_H2, PERIOD_H1, PERIOD_M30, PERIOD_M15 };
input bool EnableFloatingCompass = true;
input int  CompassXOffset        = 10;
input int  CompassYOffset        = 20;

int OnInit()
{
   SetIndexBuffer(0, dummyBuffer, INDICATOR_DATA);
   ArrayInitialize(dummyBuffer, EMPTY_VALUE);
   return INIT_SUCCEEDED;
}

int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long &tick_volume[],
                const long &volume[],
                const int &spread[])
{
   if(!EnableFloatingCompass) return rates_total;

   int buyScore = 0;
   int sellScore = 0;
   int buyWeight = 0;
   int sellWeight = 0;

   for(int i=0; i<ArraySize(TFList); i++)
   {
      ENUM_TIMEFRAMES tf = TFList[i];
      string dir, str, eta;
      double m = GetTFMagnet(tf, dir, str, eta);
      int weight = StrengthToWeight(str);
      if(dir=="ðŸŸ¢ Demand") { buyScore++; buyWeight += weight; }
      else { sellScore++; sellWeight += weight; }
   }

   int totalScore = buyScore + sellScore;
   int dominantWeight = MathMax(buyWeight, sellWeight);
   string bias = buyWeight >= sellWeight ? "Buy Bias" : "Sell Bias";
   string arrow = buyWeight >= sellWeight ? "ðŸ”º" : "ðŸ”»";
   int confidence = (int)MathFloor((double)dominantWeight / (totalScore * 5) * 100);

   string labelText = "Alfred Confidence: " + IntegerToString(confidence) + "% (" + bias + ")";
   color arrowColor = StrengthColor(WeightToLabel(dominantWeight / totalScore));

   // Position arrow + label near current price
   datetime t = iTime(_Symbol, _Period, 0);
   double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   string arrowObj = "AlfredCompassArrow";
   string labelObj = "AlfredCompassLabel";

   if(ObjectFind(0, arrowObj) < 0)
      ObjectCreate(0, arrowObj, OBJ_TEXT, 0, t, price);

   ObjectSetInteger(0, arrowObj, OBJPROP_FONTSIZE, 12);
   ObjectSetInteger(0, arrowObj, OBJPROP_COLOR, arrowColor);
   ObjectSetString(0, arrowObj, OBJPROP_TEXT, arrow);
   ObjectMove(0, arrowObj, 0, t, price + CompassYOffset * _Point);

   if(ObjectFind(0, labelObj) < 0)
      ObjectCreate(0, labelObj, OBJ_TEXT, 0, t, price);

   ObjectSetInteger(0, labelObj, OBJPROP_FONTSIZE, 10);
   ObjectSetInteger(0, labelObj, OBJPROP_COLOR, arrowColor);
   ObjectSetString(0, labelObj, OBJPROP_TEXT, labelText);
   ObjectMove(0, labelObj, 0, t, price + (CompassYOffset + 20) * _Point);

   return rates_total;
}

//== Core magnet scoring ==
double GetTFMagnet(ENUM_TIMEFRAMES tf, string &direction, string &strength, string &eta)
{
   string demandZones[] = {"DZone_LTF","DZone_H1","DZone_H4","DZone_D1"};
   string supplyZones[] = {"SZone_LTF","SZone_H1","SZone_H4","SZone_D1"};
   double bestDemand = EMPTY_VALUE, scoreD = -999;
   double bestSupply = EMPTY_VALUE, scoreS = -999;

   for(int i=0; i<ArraySize(demandZones); i++)
   {
      string z = demandZones[i];
      if(ObjectFind(0,z)>=0)
      {
         double p1 = ObjectGetDouble(0,z,OBJPROP_PRICE,0);
         double p2 = ObjectGetDouble(0,z,OBJPROP_PRICE,1);
         double mid = (p1 + p2)/2;
         double dist = MathAbs(SymbolInfoDouble(_Symbol,SYMBOL_BID) - mid);
         double width = MathAbs(p1 - p2);
         double score = 1000 - dist/_Point - width/_Point;
         if(score > scoreD) { scoreD = score; bestDemand = mid; }
      }
   }

   for(int i=0; i<ArraySize(supplyZones); i++)
   {
      string z = supplyZones[i];
      if(ObjectFind(0,z)>=0)
      {
         double p1 = ObjectGetDouble(0,z,OBJPROP_PRICE,0);
         double p2 = ObjectGetDouble(0,z,OBJPROP_PRICE,1);
         double mid = (p1 + p2)/2;
         double dist = MathAbs(SymbolInfoDouble(_Symbol,SYMBOL_BID) - mid);
         double width = MathAbs(p1 - p2);
         double score = 1000 - dist/_Point - width/_Point;
         if(score > scoreS) { scoreS = score; bestSupply = mid; }
      }
   }

   bool useDemand = (scoreD >= scoreS);
   double finalScore = useDemand ? scoreD : scoreS;
   direction = useDemand ? "ðŸŸ¢ Demand" : "ðŸ”´ Supply";
   strength = ScoreToLabel(finalScore);
   eta = "~";
   return useDemand ? bestDemand : bestSupply;
}

//== Score to label ==
string ScoreToLabel(double score)
{
   if(score <  50) return "Very Weak";
   if(score < 150) return "Weak";
   if(score < 250) return "Neutral";
   if(score < 350) return "Strong";
   return "Very Strong";
}

string WeightToLabel(int weight)
{
   if(weight <= 5)  return "Very Weak";
   if(weight <= 10) return "Weak";
   if(weight <= 15) return "Neutral";
   if(weight <= 20) return "Strong";
   return "Very Strong";
}

int StrengthToWeight(string strength)
{
   if(strength=="Very Weak")   return 1;
   if(strength=="Weak")        return 2;
   if(strength=="Neutral")     return 3;
   if(strength=="Strong")      return 4;
   if(strength=="Very Strong") return 5;
   return 0;
}

color StrengthColor(string label)
{
   if(label=="Very Weak")   return clrGray;
   if(label=="Weak")        return clrSilver;
   if(label=="Neutral")     return clrKhaki;
   if(label=="Strong")      return clrAquamarine;
   if(label=="Very Strong") return clrLime;
   return clrWhite;
}
