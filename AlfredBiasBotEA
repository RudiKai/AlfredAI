//+------------------------------------------------------------------+
//|           AlfredBiasBot_LocalTime_v3.mq5                         |
//|  MA50/MA151 + ATR14 + BE@40pips + TS@60pips + OvernightTS@15pips  |
//|  Fully uses LOCAL PC clock for session & overnight detection     |
//+------------------------------------------------------------------+
#property strict
#include <Trade\Trade.mqh>
CTrade trade;

//--- Inputs
input int             FastMAPeriod       = 50;        
input int             SlowMAPeriod       = 151;       
input int             ATRPeriod          = 14;        
input ENUM_TIMEFRAMES Timeframe          = PERIOD_M15;
input int             StartHour          = 1;         
input int             EndHour            = 23;        
input int             EndMinute          = 30;       
input int             FridayCloseHour    = 22;        
input double          LotSize            = 0.10;      
input double          ATRThreshold       = 0.00060;   
input int             BreakEvenPips      = 40;        
input int             TrailingStartExtra = 20;        
input int             TrailingStopPips   = 20;        
input int             OvernightTrailPips = 15;        

//--- Indicator handles
int hMAFast = INVALID_HANDLE;
int hMASlow = INVALID_HANDLE;
int hATR    = INVALID_HANDLE;

//--- One-bar guard
datetime lastBarTime = 0;

//+------------------------------------------------------------------+
//| Expert initialization                                           |
//+------------------------------------------------------------------+
int OnInit()
{
   hMAFast = iMA(_Symbol, Timeframe, FastMAPeriod, 0, MODE_SMA, PRICE_CLOSE);
   hMASlow = iMA(_Symbol, Timeframe, SlowMAPeriod, 0, MODE_SMA, PRICE_CLOSE);
   hATR    = iATR(_Symbol, Timeframe, ATRPeriod);
   if(hMAFast==INVALID_HANDLE || hMASlow==INVALID_HANDLE || hATR==INVALID_HANDLE)
   {
      Print("âŒ Failed to create indicator handles");
      return(INIT_FAILED);
   }

   PrintFormat(
     "âœ… Inited: MA[%d/%d], ATR[%d|thr=%.5f], BE=%dp, TS+%dp@%dp, OvernightTS=%dp, Session[%02d:00â€“%02d:%02d], FriClose@%02d:00",
     FastMAPeriod, SlowMAPeriod, ATRPeriod, ATRThreshold,
     BreakEvenPips, TrailingStartExtra, TrailingStopPips,
     OvernightTrailPips,
     StartHour, EndHour, EndMinute, FridayCloseHour
   );
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization                                         |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   IndicatorRelease(hMAFast);
   IndicatorRelease(hMASlow);
   IndicatorRelease(hATR);
   Print("â„¹ï¸ Deinitialized");
}

//+------------------------------------------------------------------+
//| Expert tick                                                     |
//+------------------------------------------------------------------+
void OnTick()
{
   // 1) One-bar guard on closed bar
   datetime barTime = iTime(_Symbol, Timeframe, 0);
   if(barTime == lastBarTime) 
      return;
   lastBarTime = barTime;

   // 2) Build two structs: barâ€™s time and PC local time
   MqlDateTime dtBar, dtLocal;
   TimeToStruct(barTime, dtBar);           // bar timestamp
   TimeToStruct(TimeLocal(), dtLocal);     // PC clock

   // 3) Optional debug: see both
   PrintFormat("â–¶ Bar %02d:%02d   |   Local %02d:%02d",
               dtBar.hour, dtBar.min,
               dtLocal.hour, dtLocal.min);

   // 4) Friday close to avoid weekend gaps (uses PC clockâ€™s dow)
   if(dtLocal.day_of_week == 5 && dtLocal.hour >= FridayCloseHour)
   {
      if(PositionSelect(_Symbol))
      {
         PrintFormat("ðŸ”” Friday %02d:00 local â€” closing for weekend", dtLocal.hour);
         trade.PositionClose(_Symbol);
      }
      return;
   }

   // 5) Overnight flag (after EndHour:EndMinute local)
   bool overnight = (dtLocal.hour > EndHour ||
                    (dtLocal.hour == EndHour && dtLocal.min >= EndMinute));
   PrintFormat("â€” Overnight mode = %s", overnight ? "YES" : "NO");

   // 6) Fetch MA & ATR (last closed bar)
   double maFastArr[1], maSlowArr[1], atrArr[1];
   if(CopyBuffer(hMAFast, 0, 1, 1, maFastArr) < 1 ||
      CopyBuffer(hMASlow, 0, 1, 1, maSlowArr) < 1 ||
      CopyBuffer(hATR,    0, 1, 1, atrArr   ) < 1)
   {
      Print("âŒ CopyBuffer failed");
      return;
   }
   double maFast = maFastArr[0], maSlow = maSlowArr[0], atr = atrArr[0];
   double price  = SymbolInfoDouble(_Symbol, SYMBOL_BID);

   // 7) ATR filter
   if(atr < ATRThreshold) 
      return;

   // 8) Detect MAâ€cross
   bool crossBull = price > maFast && price > maSlow;
   bool crossBear = price < maFast && price < maSlow;

   // 9) Manage open position
   if(PositionSelect(_Symbol))
   {
      double pip     = (_Digits==5||_Digits==3) ? _Point*10 : _Point;
      double beDist  = BreakEvenPips * pip;
      double tsStart = (BreakEvenPips + TrailingStartExtra) * pip;
      double tsSess  = TrailingStopPips * pip;
      double tsOvr   = OvernightTrailPips * pip;

      ulong  ticket = PositionGetInteger(POSITION_TICKET);
      long   type   = PositionGetInteger(POSITION_TYPE);
      double entry  = PositionGetDouble(POSITION_PRICE_OPEN);
      double currSL = PositionGetDouble(POSITION_SL);

      // 9a) Session mode: BE + session TS
      if(!overnight)
      {
         // Break-even
         if(type==POSITION_TYPE_BUY && price-entry>=beDist && currSL<entry)
         {
            trade.PositionModify(ticket, entry, 0.0);
            currSL = entry; Print("ðŸš§ BE BUY set");
         }
         if(type==POSITION_TYPE_SELL && entry-price>=beDist && (currSL==0 || currSL>entry))
         {
            trade.PositionModify(ticket, entry, 0.0);
            currSL = entry; Print("ðŸš§ BE SELL set");
         }
         // Initial trailing
         if(currSL>0 && type==POSITION_TYPE_BUY && price-entry>=tsStart)
         {
            double newSL = price - tsSess;
            if(newSL > currSL)
            {
               trade.PositionModify(ticket, newSL, 0.0);
               currSL = newSL; PrintFormat("ðŸŽ¯ Trail BUY SLâ†’%.5f", newSL);
            }
         }
         if(currSL>0 && type==POSITION_TYPE_SELL && entry-price>=tsStart)
         {
            double newSL = price + tsSess;
            if(newSL < currSL)
            {
               trade.PositionModify(ticket, newSL, 0.0);
               currSL = newSL; PrintFormat("ðŸŽ¯ Trail SELL SLâ†’%.5f", newSL);
            }
         }
      }
      // 9b) Overnight mode: tighter trailing
      else
      {
         if(type==POSITION_TYPE_BUY)
         {
            double newSL = price - tsOvr;
            if(newSL > currSL)
            {
               trade.PositionModify(ticket, newSL, 0.0);
               currSL = newSL; PrintFormat("ðŸŒ™ Overnight Trail BUY SLâ†’%.5f", newSL);
            }
         }
         else if(type==POSITION_TYPE_SELL)
         {
            double newSL = price + tsOvr;
            if(currSL==0 || newSL < currSL)
            {
               trade.PositionModify(ticket, newSL, 0.0);
               currSL = newSL; PrintFormat("ðŸŒ™ Overnight Trail SELL SLâ†’%.5f", newSL);
            }
         }
      }

      // 9c) Exit on reverse MAâ€cross anytime
      if(type==POSITION_TYPE_BUY && crossBear)
      {
         Print(">>> Exit LONG on reverse cross");
         trade.PositionClose(_Symbol);
      }
      if(type==POSITION_TYPE_SELL && crossBull)
      {
         Print(">>> Exit SHORT on reverse cross");
         trade.PositionClose(_Symbol);
      }
      return;
   }

   // 10) No open pos â†’ entries only during session
   if(!overnight
      && dtLocal.hour >= StartHour
      && (dtLocal.hour < EndHour || (dtLocal.hour == EndHour && dtLocal.min < EndMinute)))
   {
      if(crossBull)
      {
         trade.Buy(LotSize);
         Print(">>> BUY placed");
      }
      else if(crossBear)
      {
         trade.Sell(LotSize);
         Print(">>> SELL placed");
      }
   }
}
//+------------------------------------------------------------------+
