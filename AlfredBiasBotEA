//+------------------------------------------------------------------+
//|              AlfredBiasBot_LocalOffset_v5.mq5                   |
//|  MA50/MA151 + ATR14 + BE@40pips + TS@60pips + OvernightTS@15     |
//|  Session & overnight based on barTime + TimeOffset (local tz)   |
//+------------------------------------------------------------------+
#property strict
#include <Trade\Trade.mqh>
CTrade trade;

//--- Inputs
input int      FastMAPeriod       = 50;        // Fast MA period
input int      SlowMAPeriod       = 151;       // Slow MA period
input int      ATRPeriod          = 14;        // ATR period
input ENUM_TIMEFRAMES Timeframe   = PERIOD_M15;// Chart timeframe
input int      StartHour          = 1;         // Session start hour (local)
input int      EndHour            = 23;        // Session end hour (local)
input int      EndMinute          = 30;        // Session end minute (local)
input int      FridayCloseHour    = 22;        // Friday close hour (local)
input double   LotSize            = 0.10;      // Trade size (lots)
input double   ATRThreshold       = 0.00060;   // Minimum ATR filter
input int      BreakEvenPips      = 40;        // Pips to move SL to break-even
input int      TrailingStartExtra = 20;        // Extra pips beyond BE to start trailing
input int      TrailingStopPips   = 20;        // TS distance during session
input int      OvernightTrailPips = 15;        // TS distance after session
input int      TimeOffset         = 3;         // Local time = server time + offset hours

//--- Indicator handles & bar guard
int    hMAFast      = INVALID_HANDLE;
int    hMASlow      = INVALID_HANDLE;
int    hATR         = INVALID_HANDLE;
datetime lastBarTime= 0;

//+------------------------------------------------------------------+
//| Expert initialization                                           |
//+------------------------------------------------------------------+
int OnInit()
{
   // Create indicators
   hMAFast = iMA(_Symbol, Timeframe, FastMAPeriod, 0, MODE_SMA, PRICE_CLOSE);
   hMASlow = iMA(_Symbol, Timeframe, SlowMAPeriod, 0, MODE_SMA, PRICE_CLOSE);
   hATR    = iATR(_Symbol, Timeframe, ATRPeriod);
   if(hMAFast==INVALID_HANDLE||hMASlow==INVALID_HANDLE||hATR==INVALID_HANDLE)
   {
      Print("❌ Failed to create indicator handles");
      return(INIT_FAILED);
   }
   PrintFormat(
     "✅ Init: MA[%d/%d] ATR[%d|thr=%.5f] BE=%dp TS+%dp@%dp OTS=%dp  "
     "Session[%02d:%02d–%02d:%02d] FriClose@%02d Off=%dh",
     FastMAPeriod,SlowMAPeriod,ATRPeriod,ATRThreshold,
     BreakEvenPips,TrailingStartExtra,TrailingStopPips,OvernightTrailPips,
     StartHour,0, EndHour,EndMinute, FridayCloseHour, TimeOffset
   );
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization                                         |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   IndicatorRelease(hMAFast);
   IndicatorRelease(hMASlow);
   IndicatorRelease(hATR);
   Print("ℹ️ Deinitialized");
}

//+------------------------------------------------------------------+
//| Expert tick handler                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   // 1) New‐bar guard
   datetime barTime = iTime(_Symbol, Timeframe, 0);
   if(barTime == lastBarTime) return;
   lastBarTime = barTime;

   // 2) Server bar struct
   MqlDateTime dtBar;
   TimeToStruct(barTime, dtBar);

   // 3) Compute local bar time by offset
   datetime localTs = barTime + TimeOffset * 3600;
   MqlDateTime dtLocal;
   TimeToStruct(localTs, dtLocal);

   // 4) Friday gap‐avoidance (local)
   if(dtLocal.day_of_week == 5 && dtLocal.hour >= FridayCloseHour)
   {
      if(PositionSelect(_Symbol))
      {
         PrintFormat("🔔 Friday %02d:00 local — closing for weekend", dtLocal.hour);
         trade.PositionClose(_Symbol);
      }
      return;
   }

   // 5) Minute‐based session detection
   int localTotalMin = dtLocal.hour * 60 + dtLocal.min;
   int sessionStart  = StartHour * 60;              // e.g. 60
   int sessionEnd    = EndHour * 60 + EndMinute;    // e.g. 1410
   bool inSession    = (localTotalMin >= sessionStart) && (localTotalMin < sessionEnd);
   bool overnight    = !inSession;

   // Debug print
   PrintFormat(
     "▶ Bar %02d:%02d(srv) | Loc %02d:%02d(min:%4d) — inSession=%s overnight=%s",
     dtBar.hour, dtBar.min,
     dtLocal.hour, dtLocal.min, localTotalMin,
     inSession  ? "YES" : "NO",
     overnight  ? "YES" : "NO"
   );

   // 6) Fetch MA & ATR (last closed bar)
   double maFastArr[1], maSlowArr[1], atrArr[1];
   if(CopyBuffer(hMAFast, 0, 1, 1, maFastArr) < 1 ||
      CopyBuffer(hMASlow, 0, 1, 1, maSlowArr) < 1 ||
      CopyBuffer(hATR,    0, 1, 1, atrArr   ) < 1)
   {
      Print("❌ CopyBuffer failed");
      return;
   }
   double maFast = maFastArr[0], maSlow = maSlowArr[0], atr = atrArr[0];
   double price  = SymbolInfoDouble(_Symbol, SYMBOL_BID);

   // 7) ATR filter
   if(atr < ATRThreshold) return;

   // 8) MA‐cross signals
   bool crossBull = (price > maFast && price > maSlow);
   bool crossBear = (price < maFast && price < maSlow);

   // 9) Position management
   if(PositionSelect(_Symbol))
   {
      // pip math
      double pip     = (_Digits==5||_Digits==3) ? _Point*10 : _Point;
      double beDist  = BreakEvenPips * pip;
      double tsStart = (BreakEvenPips + TrailingStartExtra) * pip;
      double tsSess  = TrailingStopPips * pip;
      double tsOvr   = OvernightTrailPips * pip;

      ulong  ticket = PositionGetInteger(POSITION_TICKET);
      long   type   = PositionGetInteger(POSITION_TYPE);
      double entry  = PositionGetDouble(POSITION_PRICE_OPEN);
      double currSL = PositionGetDouble(POSITION_SL);

      if(inSession)
      {
         // Break-even
         if(type==POSITION_TYPE_BUY && price-entry>=beDist && currSL<entry)
         {
            trade.PositionModify(ticket, entry, 0.0);
            currSL = entry; Print("🚧 BE BUY set");
         }
         if(type==POSITION_TYPE_SELL && entry-price>=beDist && (currSL==0||currSL>entry))
         {
            trade.PositionModify(ticket, entry, 0.0);
            currSL = entry; Print("🚧 BE SELL set");
         }
         // Session trailing
         if(currSL>0 && type==POSITION_TYPE_BUY && price-entry>=tsStart)
         {
            double newSL = price - tsSess;
            if(newSL > currSL)
            {
               trade.PositionModify(ticket, newSL, 0.0);
               currSL=newSL; PrintFormat("🎯 Trail BUY→%.5f",newSL);
            }
         }
         if(currSL>0 && type==POSITION_TYPE_SELL && entry-price>=tsStart)
         {
            double newSL = price + tsSess;
            if(newSL < currSL)
            {
               trade.PositionModify(ticket, newSL, 0.0);
               currSL=newSL; PrintFormat("🎯 Trail SELL→%.5f",newSL);
            }
         }
      }
      else
      {
         // Overnight trailing
         if(type==POSITION_TYPE_BUY)
         {
            double newSL = price - tsOvr;
            if(newSL > currSL)
            {
               trade.PositionModify(ticket, newSL, 0.0);
               currSL=newSL; PrintFormat("🌙 O/N Trail BUY→%.5f",newSL);
            }
         }
         else
         {
            double newSL = price + tsOvr;
            if(currSL==0 || newSL < currSL)
            {
               trade.PositionModify(ticket, newSL, 0.0);
               currSL=newSL; PrintFormat("🌙 O/N Trail SELL→%.5f",newSL);
            }
         }
      }

      // Reverse‐cross exit
      if(type==POSITION_TYPE_BUY && crossBear)
      {
         Print(">>> Exit LONG on reverse cross");
         trade.PositionClose(_Symbol);
      }
      if(type==POSITION_TYPE_SELL && crossBull)
      {
         Print(">>> Exit SHORT on reverse cross");
         trade.PositionClose(_Symbol);
      }
   }
   else if(inSession)
   {
      // New entries only in-session
      if(crossBull)
      {
         Print(">>> Placing BUY");
         trade.Buy(LotSize);
      }
      else if(crossBear)
      {
         Print(">>> Placing SELL");
         trade.Sell(LotSize);
      }
   }
}
//+------------------------------------------------------------------+
